<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>투자 수익(+물타기) 계산기 Ver.2.1</title> <link href="https://fonts.googleapis.com/2024/2/af/4172776366-2.webp?family=Noto+Sans+KR&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    body {
      font-family: 'Noto Sans KR', sans-serif;
      padding: 20px;
      max-width: 800px;
      margin: auto;
      transition: background-color 0.3s, color 0.3s;
    }
    section {
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
    }
    label {
      font-weight: bold;
      display: block;
      margin-top: 10px;
    }
    input, button {
      margin: 5px 0;
      padding: 10px; /* 패딩 조정 */
      width: 100%;
      box-sizing: border-box;
      border-radius: 4px; /* 통일된 radius */
      border: 1px solid #ccc; /* 테두리 추가 */
    }
    button {
      background-color: #4CAF50; /* 기본 버튼 색상 */
      color: white;
      cursor: pointer;
      border: none;
    }
    button:hover {
      opacity: 0.9;
    }
    button.secondary { /* 보조 버튼 스타일 */
        background-color: #f0f0f0;
        color: #333;
        border: 1px solid #ccc;
    }
    button:disabled {
        background-color: #ccc;
        cursor: not-allowed;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    table, th, td {
      border: 1px solid #ccc;
    }
    th {
      background: #f2f2f2;
    }
    td, th {
      padding: 8px;
      text-align: center;
    }
    .positive { color: red; font-weight: bold; }
    .negative { color: blue; font-weight: bold; }
    canvas {
      margin-top: 20px;
      max-width: 100%;
    }
    .buy-block {
      margin-bottom: 10px;
      padding: 10px;
      border: 1px dashed #aaa;
      border-radius: 6px;
      background: #f9f9f9;
    }

    /* 다크 모드 스타일 */
    body.dark {
      background-color: #121212;
      color: #e0e0e0;
    }
    body.dark section {
      background-color: #1e1e1e;
      border-color: #444;
    }
    body.dark input,
    body.dark button.secondary { /* 다크모드 보조 버튼 */
      background-color: #2c2c2c;
      color: #fff;
      border: 1px solid #555;
    }
    body.dark button { /* 다크모드 기본 버튼 (초록색 유지 또는 변경) */
        /* background-color: #005704; */
    }
    body.dark table, body.dark th, body.dark td {
      border-color: #555;
    }
    body.dark th {
      background-color: #2a2a2a;
    }
    body.dark .buy-block {
      background-color: #2a2a2a;
      border-color: #555;
    }

    /* 알림 메시지 스타일 */
    .notification {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 20px;
        border-radius: 5px;
        color: white;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.5s, bottom 0.5s;
        font-size: 0.9em;
    }
    .notification.show {
        opacity: 1;
        bottom: 30px;
    }
    .notification.success { background-color: #4CAF50; }
    .notification.error { background-color: #f44336; }
    .notification.info { background-color: #2196F3; }

    /* 입력 그룹 스타일 */
    .input-group {
        display: flex;
        gap: 10px;
        align-items: center;
    }
    .input-group label {
        flex-basis: 120px; /* 레이블 너비 고정 */
        margin-top: 0;
    }
    .input-group input {
        flex-grow: 1;
    }

    @media (max-width: 600px) {
      body { padding: 10px; }
      section { padding: 10px; }
      h2 { font-size: 1.4em; }
      h3 { font-size: 1.1em; }
      input, button { font-size: 1em; padding: 12px 10px; }
      button { margin-top: 8px; }
      table td, table th { font-size: 0.9em; padding: 6px; }
      canvas { height: auto !important; }
      .input-group { flex-direction: column; align-items: stretch; }
      .input-group label { flex-basis: auto; margin-bottom: 5px; }
    }
  </style>
</head>
<body>

<h2>💸 투자 수익(+물타기) 계산기 Ver.2.1</h2>
<div style="text-align: right; margin-bottom: 10px;">
  <button id="darkModeBtn" onclick="toggleDarkMode()">🌙 다크모드 ON</button>
</div>

<section id="settingsSection">
    <h3>⚙️ 수수료 및 세금 설정</h3>
    <div class="input-group">
        <label for="buyFeeRate">매수 수수료 (%)</label>
        <input type="number" id="buyFeeRate" value="0.015" step="0.001" min="0">
    </div>
    <div class="input-group">
        <label for="sellFeeRate">매도 수수료 (%)</label>
        <input type="number" id="sellFeeRate" value="0.015" step="0.001" min="0">
    </div>
    <div class="input-group">
        <label for="taxRate">세금 (%)</label>
        <input type="number" id="taxRate" value="0.2" step="0.01" min="0">
    </div>
    <button id="setFeesToZeroBtn" class="secondary" style="margin-top: 10px;">수수료/세금 미적용 (0%로 설정)</button>
    <small style="display:block; color:gray; margin-top:5px;">
        ※ 국내 주식 기준 기본값 (증권사마다 다를 수 있으며, 세금은 국가/상품별로 상이)
    </small>
</section>

<section id="initialPurchaseSection">
  <h3>① 최초 매수 입력</h3>
  <div class="input-group">
    <label for="initPrice">최초 매수가 (원)</label>
    <input type="number" id="initPrice" min="0">
  </div>
  <div class="input-group">
    <label for="initAmount">최초 매수량 (주)</label>
    <input type="number" id="initAmount" min="1">
  </div>
  <button id="setInitialPurchaseBtn" onclick="setInitialPurchase()">✔ 최초 매수 입력</button>
  <button id="clearInitialPurchaseBtn" class="secondary" onclick="clearInitialPurchase()">🧹 최초 매수 초기화</button>
</section>

<section>
  <h3>② 추가 매수 입력</h3>
  <div id="additionalInputs"></div>
  <button onclick="addBuyBlock()">➕ 추가 매수 항목 추가</button>
  <button class="secondary" onclick="clearAdditionalBuys()">➖ 추가 매수 전체 초기화</button>
</section>

<section>
  <h3>③ 평균 단가 & 손익 계산</h3>
  <div id="summaryResult"></div>
  <div class="input-group">
    <label for="currentPriceInput">현재 주가 (원)</label>
    <input type="number" id="currentPriceInput" min="0">
  </div>
  <small style="display:block; color:gray; margin-bottom:5px;">
    ※ 입력하지 않으면 마지막 추가 매수가 또는 최초 매수가로 자동 계산됩니다.
  </small>
  <button onclick="calculateProfit()">📈 손익 계산</button>
  <button class="secondary" onclick="clearProfitCalculation()">📉 손익 계산 초기화</button>
  <div id="profitResultTable"></div>
  <div id="breakEven" style="margin-top: 10px;"></div>
</section>

<section>
  <h3>④ 목표 수익률 기반 매도 가격 계산</h3>
  <div class="input-group">
    <label for="targetROI">목표 수익률 (%)</label>
    <input type="number" id="targetROI" min="0">
  </div>
  <button onclick="calculateTargetSellPrice()">🎯 매도 목표가 계산</button>
  <div id="targetPriceResult"></div>
  <div id="targetPriceTable"></div>
</section>

<section>
  <h3>⑤ 데이터 저장 및 차트</h3>
  <button onclick="saveData()">💾 데이터 저장</button>
  <button class="secondary" onclick="loadData()">📂 불러오기</button>
  <button onclick="downloadExcel()">📊 엑셀로 저장</button>
  <button class="secondary" onclick="resetAllData()">🔄 전체 초기화</button>
</section>

<canvas id="avgPriceChart" width="800" height="400" style="width: 100%; max-width: 800px;"></canvas>
<canvas id="volumeChart" width="800" height="400" style="width: 100%; max-width: 800px; margin-top: 40px;"></canvas>

<section>
  <h3>⑥ 투자 비중 (매수 금액 기준)</h3>
  <canvas id="investmentPieChart" width="800" height="400" style="width: 100%; max-width: 600px; margin: 20px auto; display: block;"></canvas>
</section>

<div id="notificationArea" class="notification"></div>

<script>
// --- Constants ---
const LS_KEY_DATA = "investmentCalculatorData_v2_1"; // 로컬 스토리지 키 변경 (버전업)
const LS_KEY_DARK_MODE = "investmentCalculatorDarkMode_v2_1";

// --- DOM Elements Cache ---
const dom = {};

// --- Application State ---
let appState = {
  purchases: [], // { price: Number, amount: Number, costWithFee: Number, id: String }
  avgBuyPrice: 0,
  totalAmount: 0,
  totalInvestedCost: 0,
  fees: {
    buyRate: 0.00015, // 기본값 설정 (0.015%)
    sellRate: 0.00015, // 기본값 설정 (0.015%)
    taxRate: 0.002     // 기본값 설정 (0.2%)
  },
  currentPrice: 0,
  targetROI: 0,
};

// --- Chart Instances ---
let avgPriceChartInstance = null;
let volumeChartInstance = null;
let investmentPieChartInstance = null;

// --- Helper Functions ---
function isDarkChartElement() {
    return document.body.classList.contains('dark');
}

// --- Initialization ---
document.addEventListener('DOMContentLoaded', () => {
  cacheDOMElements();
  initializeFeeEventListeners(); // 이벤트 리스너는 여기서 한 번만 등록
  loadSettings();           // 초기 appState.fees 값 로드 (DOM 값 기준)
  loadData();               // 저장된 데이터 로드 (appState 덮어쓰기 가능)
  initializeCharts();       // 차트 초기화
  updateDarkModeUI(localStorage.getItem(LS_KEY_DARK_MODE) === 'on');
  dom.setFeesToZeroBtn.addEventListener('click', setFeesToZeroAndRecalculate);
});

function cacheDOMElements() {
  dom.buyFeeRateInput = document.getElementById('buyFeeRate');
  dom.sellFeeRateInput = document.getElementById('sellFeeRate');
  dom.taxRateInput = document.getElementById('taxRate');
  dom.setFeesToZeroBtn = document.getElementById('setFeesToZeroBtn');

  dom.initPriceInput = document.getElementById('initPrice');
  dom.initAmountInput = document.getElementById('initAmount');
  dom.setInitialPurchaseBtn = document.getElementById('setInitialPurchaseBtn');
  dom.clearInitialPurchaseBtn = document.getElementById('clearInitialPurchaseBtn');
  dom.initialPurchaseSection = document.getElementById('initialPurchaseSection');

  dom.additionalInputsContainer = document.getElementById('additionalInputs');

  dom.summaryResultDiv = document.getElementById('summaryResult');
  dom.currentPriceInput = document.getElementById('currentPriceInput');
  dom.profitResultTableDiv = document.getElementById('profitResultTable');
  dom.breakEvenDiv = document.getElementById('breakEven');

  dom.targetROIInput = document.getElementById('targetROI');
  dom.targetPriceResultDiv = document.getElementById('targetPriceResult');
  dom.targetPriceTableDiv = document.getElementById('targetPriceTable');

  dom.notificationArea = document.getElementById('notificationArea');
  dom.darkModeBtn = document.getElementById('darkModeBtn');

  dom.avgPriceChartCanvas = document.getElementById('avgPriceChart');
  dom.volumeChartCanvas = document.getElementById('volumeChart');
  dom.investmentPieChartCanvas = document.getElementById('investmentPieChart');
}

function initializeFeeEventListeners() {
    ['buyFeeRateInput', 'sellFeeRateInput', 'taxRateInput'].forEach(key => {
        const inputElement = dom[key];
        if (inputElement) {
            inputElement.addEventListener('change', () => {
                // 입력 필드 변경 시 appState.fees 업데이트 및 재계산
                appState.fees.buyRate = parseFloat(dom.buyFeeRateInput.value) / 100 || 0;
                appState.fees.sellRate = parseFloat(dom.sellFeeRateInput.value) / 100 || 0;
                appState.fees.taxRate = parseFloat(dom.taxRateInput.value) / 100 || 0;
                recalculateAndUpdateUI();
                showNotification('수수료/세금 설정이 변경되었습니다. 관련 정보가 업데이트됩니다.', 'info');
            });
        }
    });
}

function loadSettings() { // 페이지 로드 시 DOM의 기본값으로 appState.fees를 설정
    appState.fees.buyRate = parseFloat(dom.buyFeeRateInput.value) / 100 || 0;
    appState.fees.sellRate = parseFloat(dom.sellFeeRateInput.value) / 100 || 0;
    appState.fees.taxRate = parseFloat(dom.taxRateInput.value) / 100 || 0;
}

function setFeesToZeroAndRecalculate() {
  dom.buyFeeRateInput.value = '0';
  dom.sellFeeRateInput.value = '0';
  dom.taxRateInput.value = '0';

  // appState.fees도 0으로 직접 업데이트
  appState.fees.buyRate = 0;
  appState.fees.sellRate = 0;
  appState.fees.taxRate = 0;

  recalculateAndUpdateUI();
  showNotification('수수료 및 세금이 0%로 설정되어 재계산되었습니다.', 'info');
}

function recalculateAndUpdateUI() {
    // purchases 유무에 관계없이 항상 기본 상태 업데이트 먼저 수행
    updateAggregates(); // purchases가 비면 내부적으로 0으로 처리
    renderSummary();    // purchases가 비면 "매수 내역 없음" 표시

    if (appState.purchases.length > 0) {
        // 손익 계산은 현재가 입력이 있거나, 이전에 계산된 appState.currentPrice가 있을 때만
        if (dom.currentPriceInput.value || appState.currentPrice > 0) {
            calculateProfit();
        } else {
            clearProfitCalculation(); // 아니면 손익 관련 UI 초기화
        }
        // 목표가 계산도 목표 ROI 입력이 있거나, 이전에 계산된 appState.targetROI가 있을 때만
        if (dom.targetROIInput.value || appState.targetROI !== 0) {
            calculateTargetSellPrice();
        } else {
            clearTargetPriceCalculation(); // 아니면 목표가 관련 UI 초기화
        }
    } else { // 매수 내역이 아예 없을 때
        clearProfitCalculation();
        clearTargetPriceCalculation();
    }
    updateCharts(); // 모든 차트 업데이트 (내부적으로 purchases 길이에 따라 처리)
}

function showNotification(message, type = 'info') {
  dom.notificationArea.textContent = message;
  dom.notificationArea.className = `notification ${type} show`;
  setTimeout(() => {
    dom.notificationArea.classList.remove('show');
  }, 3000);
}

function renderSummary() {
  if (appState.purchases.length === 0) {
    dom.summaryResultDiv.innerHTML = '매수 내역이 없습니다.';
    return;
  }
  dom.summaryResultDiv.innerHTML = `
    총 보유 수량: ${appState.totalAmount.toLocaleString()} 주<br>
    평균 매수 단가 (수수료 포함): ${appState.avgBuyPrice.toLocaleString('ko-KR', {minimumFractionDigits: 2, maximumFractionDigits: 2})} 원<br>
    총 투자 원금 (수수료 포함): ${appState.totalInvestedCost.toLocaleString('ko-KR', {minimumFractionDigits: 2, maximumFractionDigits: 2})} 원
  `;
}

function toggleInitialPurchaseInputs(disabled) {
    dom.initPriceInput.disabled = disabled;
    dom.initAmountInput.disabled = disabled;
    dom.setInitialPurchaseBtn.disabled = disabled;
    dom.initialPurchaseSection.style.opacity = disabled ? '0.7' : '1';
}

function setInitialPurchase() {
  const price = parseFloat(dom.initPriceInput.value);
  const amount = parseInt(dom.initAmountInput.value);

  if (isNaN(price) || price <= 0 || isNaN(amount) || amount <= 0) {
    showNotification('최초 매수가와 수량은 0보다 큰 값을 입력해야 합니다.', 'error');
    return;
  }

  appState.purchases = [{ price, amount, id: `initial-${Date.now()}` }];
  recalculateAndUpdateUI();
  toggleInitialPurchaseInputs(true);
  showNotification(`최초 매수 입력 완료: ${price.toLocaleString()}원, ${amount.toLocaleString()}주`, 'success');
}

function clearInitialPurchase() {
  dom.initPriceInput.value = '';
  dom.initAmountInput.value = '';

  if (appState.purchases.length === 1 && dom.additionalInputsContainer.children.length === 0) {
      appState.purchases = [];
  } else if (appState.purchases.length > 0 && dom.additionalInputsContainer.children.length > 0) {
      showNotification('최초 매수를 수정/삭제하려면 "전체 초기화"를 이용하거나, 추가 매수를 먼저 모두 제거해주세요.', 'info');
      return;
  } else {
      appState.purchases = [];
  }

  recalculateAndUpdateUI();
  toggleInitialPurchaseInputs(false);
  showNotification('최초 매수 정보가 초기화되었습니다.', 'info');
}


function addBuyBlock() {
  if (appState.purchases.length === 0) {
    showNotification('최초 매수를 먼저 입력해주세요.', 'error');
    return;
  }
  const block = document.createElement('div');
  block.className = 'buy-block';
  const blockId = `buyBlock-${Date.now()}`;
  block.innerHTML = `
    <div class="input-group">
        <label for="addPrice-${blockId}">추가 매수가 (원)</label>
        <input type="number" id="addPrice-${blockId}" min="0">
    </div>
    <div class="input-group">
        <label for="addAmount-${blockId}">추가 매수량 (주)</label>
        <input type="number" id="addAmount-${blockId}" min="1">
    </div>
    <button onclick="applyBuy(this, '${blockId}')">✔ 이 매수 반영</button>
    <button class="secondary" onclick="removeBuyBlock(this, '${blockId}')">❌ 이 매수 삭제</button>
  `;
  dom.additionalInputsContainer.appendChild(block);
  block.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

function applyBuy(button, blockId) {
  const block = button.closest('.buy-block');
  const priceInput = block.querySelector(`#addPrice-${blockId}`);
  const amountInput = block.querySelector(`#addAmount-${blockId}`);
  const price = parseFloat(priceInput.value);
  const amount = parseInt(amountInput.value);

  if (isNaN(price) || price <= 0 || isNaN(amount) || amount <= 0) {
    showNotification('추가 매수가와 수량은 0보다 큰 값을 입력해야 합니다.', 'error');
    return;
  }
  if (button.disabled) {
      showNotification('이미 반영된 매수입니다.', 'info');
      return;
  }

  appState.purchases.push({ price, amount, id: blockId });
  recalculateAndUpdateUI();

  priceInput.disabled = true;
  amountInput.disabled = true;
  button.textContent = '✅ 반영됨';
  button.disabled = true;
  const removeButton = block.querySelector('button.secondary');
  if(removeButton) removeButton.textContent = '❌ 반영된 항목 삭제';
  showNotification(`추가 매수 반영: ${price.toLocaleString()}원, ${amount.toLocaleString()}주`, 'success');
}

function removeBuyBlock(button, blockId) {
    const blockToRemove = button.closest('.buy-block');
    // '반영' 버튼 (첫 번째 버튼)의 비활성화 여부로 확인
    const applyButton = blockToRemove.querySelector('button[onclick^="applyBuy"]');
    const isReflected = applyButton ? applyButton.disabled : false;

    if (isReflected) {
        const purchaseIndex = appState.purchases.findIndex(p => p.id === blockId);
        if (purchaseIndex > -1) {
            // 삭제하려는 항목이 최초 매수(index 0)이고, 추가 매수가 더 있다면 단순 삭제는 위험.
            // 이 경우 clearInitialPurchase()와 유사한 경고 또는 전체 초기화 유도.
            // 단, 현재 최초 매수는 id가 "initial-..." 형태이므로 이 ID로 구분 가능.
            if (appState.purchases[purchaseIndex].id.startsWith('initial-') && appState.purchases.length > 1) {
                showNotification('반영된 최초 매수를 삭제하려면 "최초 매수 초기화"를 사용하거나 "전체 초기화" 후 재입력해주세요. (추가 매수가 있는 경우)', 'error');
                return;
            }
            appState.purchases.splice(purchaseIndex, 1);
            if (appState.purchases.length === 0) {
                toggleInitialPurchaseInputs(false);
            }
            recalculateAndUpdateUI();
            blockToRemove.remove();
            showNotification('반영된 매수 항목이 삭제되고 재계산되었습니다.', 'success');
        } else {
            showNotification('삭제할 항목을 찾지 못했습니다 (ID: ' + blockId + '). DOM에서만 제거합니다.', 'error');
            blockToRemove.remove();
        }
    } else {
        blockToRemove.remove();
        showNotification('추가 매수 항목(미반영)이 삭제되었습니다.', 'info');
    }
}

function clearAdditionalBuys() {
  if (appState.purchases.length <= 1 && dom.additionalInputsContainer.children.length === 0) {
    showNotification('초기화할 추가 매수 내역이 없습니다.', 'info');
    return;
  }
  if (appState.purchases.length > 0) {
    // 최초 매수 건만 남기되, 최초 매수 건이 실제로 존재하는지 확인
    const initialPurchase = appState.purchases.find(p => p.id && p.id.startsWith('initial-'));
    appState.purchases = initialPurchase ? [initialPurchase] : [];
  } else {
    appState.purchases = [];
  }
  dom.additionalInputsContainer.innerHTML = '';
  recalculateAndUpdateUI();
  showNotification('추가 매수 정보가 모두 초기화되었습니다.', 'success');
}

function updateAggregates() {
  if (appState.purchases.length === 0) {
    appState.totalAmount = 0;
    appState.totalInvestedCost = 0;
    appState.avgBuyPrice = 0;
    return;
  }
  let totalAmount = 0;
  let totalCost = 0;
  appState.purchases.forEach(p => {
    // p.costWithFee가 이미 계산된 상태로 purchases에 저장될 수도 있고, 여기서 매번 계산할 수도 있음.
    // 현재는 applyBuy에서 purchases에 넣을 때 costWithFee를 계산하지 않으므로 여기서 계산.
    const costWithFee = p.price * p.amount * (1 + appState.fees.buyRate);
    p.costWithFee = costWithFee; // appState.purchases 객체에도 저장 (파이차트 등에서 활용 위함)
    totalAmount += p.amount;
    totalCost += costWithFee;
  });
  appState.totalAmount = totalAmount;
  appState.totalInvestedCost = totalCost;
  appState.avgBuyPrice = totalAmount > 0 ? totalCost / totalAmount : 0;
}

function calculateProfit() {
  if (appState.purchases.length === 0) {
    dom.profitResultTableDiv.innerHTML = '';
    dom.breakEvenDiv.innerHTML = '';
    return;
  }
  const currentPriceStr = dom.currentPriceInput.value;
  let currentPrice;

  if (currentPriceStr === '') {
      // currentPrice가 0이거나, 입력이 없을 때만 마지막 매수가 또는 이전 appState.currentPrice 사용
      if (appState.currentPrice > 0) {
          currentPrice = appState.currentPrice; // 이전에 계산된 값 사용
          dom.currentPriceInput.value = currentPrice; // 필드에도 반영
      } else if (appState.purchases.length > 0) {
          currentPrice = appState.purchases[appState.purchases.length - 1].price;
          dom.currentPriceInput.value = currentPrice;
          showNotification(`현재가가 자동 입력되었습니다 (마지막 매수가: ${currentPrice.toLocaleString()}원).`, 'info');
      } else { return; } // 더 이상 진행 불가
  } else {
      currentPrice = parseFloat(currentPriceStr);
  }

  if (isNaN(currentPrice) || currentPrice < 0) {
    showNotification('올바른 현재 주가를 입력하세요.', 'error');
    return;
  }
  appState.currentPrice = currentPrice;

  const grossMarketValue = currentPrice * appState.totalAmount;
  const netMarketValue = grossMarketValue * (1 - appState.fees.sellRate - appState.fees.taxRate);
  const profitOrLoss = netMarketValue - appState.totalInvestedCost;
  const roi = appState.totalInvestedCost > 0 ? (profitOrLoss / appState.totalInvestedCost) * 100 : 0;
  const colorClass = profitOrLoss >= 0 ? 'positive' : 'negative';

  dom.profitResultTableDiv.innerHTML = `
    <table>
      <tr><th>구분</th><th>금액(원) / 비율(%)</th></tr>
      <tr><td>총 투자 원금 (매수 수수료 포함)</td><td>${appState.totalInvestedCost.toLocaleString('ko-KR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td></tr>
      <tr><td>현재 평가 금액 (매도 수수료/세금 차감 전)</td><td>${grossMarketValue.toLocaleString('ko-KR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td></tr>
      <tr><td>예상 순 평가 금액 (매도 수수료/세금 차감 후)</td><td>${netMarketValue.toLocaleString('ko-KR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td></tr>
      <tr><td class="${colorClass}">예상 순손익</td><td class="${colorClass}">${profitOrLoss.toLocaleString('ko-KR', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td></tr>
      <tr><td class="${colorClass}">예상 수익률</td><td class="${colorClass}">${roi.toFixed(2)}%</td></tr>
    </table>`;

  let breakEvenPrice = 0;
  if (appState.totalAmount > 0 && (1 - appState.fees.sellRate - appState.fees.taxRate) > 0) {
      breakEvenPrice = appState.totalInvestedCost / (appState.totalAmount * (1 - appState.fees.sellRate - appState.fees.taxRate));
  } else if (appState.totalAmount > 0) {
      breakEvenPrice = Infinity;
  }
  dom.breakEvenDiv.innerHTML = `🎯 <strong>손익분기점 주가 (매도 수수료/세금 고려): ${breakEvenPrice === Infinity ? "도달 불가능" : breakEvenPrice.toLocaleString('ko-KR', {minimumFractionDigits:2, maximumFractionDigits:2})} 원</strong>`;
  // updateCharts(); // recalculateAndUpdateUI에서 마지막에 한 번 호출
}

function clearProfitCalculation() {
  dom.currentPriceInput.value = '';
  dom.profitResultTableDiv.innerHTML = '';
  dom.breakEvenDiv.innerHTML = '';
  appState.currentPrice = 0;
  if (appState.purchases.length > 0) updateCharts();
  showNotification('손익 계산 결과가 초기화되었습니다.', 'info');
}

function calculateTargetSellPrice() {
  const targetROIStr = dom.targetROIInput.value;
  if (targetROIStr === '') { // 목표 ROI 입력이 없으면 계산 안 함 (또는 이전 값으로 계산)
      if (appState.targetROI === 0) { // appState에도 이전 값이 없으면 UI 초기화
        dom.targetPriceResultDiv.innerHTML = '';
        dom.targetPriceTableDiv.innerHTML = '';
        return;
      }
      // appState.targetROI에 값이 있으면 그 값으로 계산 (아래 로직으로 이어짐)
  }
  const targetROI = parseFloat(targetROIStr || appState.targetROI); // 입력값 우선, 없으면 appState 값

  if (isNaN(targetROI)) {
      showNotification('목표 수익률을 숫자로 입력하세요.', 'error');
      dom.targetPriceResultDiv.innerHTML = '';
      dom.targetPriceTableDiv.innerHTML = '';
      return;
  }

  if (appState.purchases.length === 0) {
    return;
  }
  if (targetROI < -100) {
      showNotification('목표 수익률은 -100% 이상으로 입력해주세요.', 'error');
      return;
  }
  appState.targetROI = targetROI;

  const targetNetProfit = appState.totalInvestedCost * (targetROI / 100);
  const targetNetMarketValue = appState.totalInvestedCost + targetNetProfit;
  let targetSellPrice = 0;
  if (appState.totalAmount > 0 && (1 - appState.fees.sellRate - appState.fees.taxRate) > 0) {
      targetSellPrice = targetNetMarketValue / (appState.totalAmount * (1 - appState.fees.sellRate - appState.fees.taxRate));
  } else if (appState.totalAmount > 0) {
      targetSellPrice = Infinity;
  }
  const colorClass = targetNetProfit >= 0 ? 'positive' : 'negative';
  dom.targetPriceResultDiv.innerText =
    `📌 ${targetROI}% 순수익을 위한 매도 목표가는 ${targetSellPrice === Infinity ? "도달 불가능" : targetSellPrice.toLocaleString('ko-KR', {minimumFractionDigits:2, maximumFractionDigits:2})} 원입니다.`;
  dom.targetPriceTableDiv.innerHTML = `
    <table>
      <tr><th>항목</th><th>금액(원) / 비율(%)</th></tr>
      <tr><td>평균 매수 단가 (수수료 포함)</td><td>${appState.avgBuyPrice.toLocaleString('ko-KR', {minimumFractionDigits:2, maximumFractionDigits:2})}</td></tr>
      <tr><td class="${colorClass}">목표 매도가 (${targetROI}%)</td><td class="${colorClass}">${targetSellPrice === Infinity ? "도달 불가능" : targetSellPrice.toLocaleString('ko-KR', {minimumFractionDigits:2, maximumFractionDigits:2})}</td></tr>
      <tr><td>총 투자 원금</td><td>${appState.totalInvestedCost.toLocaleString('ko-KR', {minimumFractionDigits:2, maximumFractionDigits:2})}</td></tr>
      <tr><td class="${colorClass}">예상 순수익 금액</td><td class="${colorClass}">${targetNetProfit.toLocaleString('ko-KR', {minimumFractionDigits:2, maximumFractionDigits:2})}</td></tr>
      <tr><td>예상 총 순자산 가치 (매도 후)</td><td>${targetNetMarketValue.toLocaleString('ko-KR', {minimumFractionDigits:2, maximumFractionDigits:2})}</td></tr>
    </table>`;
  // updateCharts(); // recalculateAndUpdateUI에서 마지막에 한 번 호출
}

function clearTargetPriceCalculation() {
    dom.targetROIInput.value = '';
    dom.targetPriceResultDiv.innerHTML = '';
    dom.targetPriceTableDiv.innerHTML = '';
    appState.targetROI = 0;
    if (appState.purchases.length > 0) updateCharts();
    showNotification('매도 목표가 계산 결과가 초기화되었습니다.', 'info');
}

function initializeCharts() {
    const commonChartOptions = { // 모든 차트에 공통으로 적용될 옵션 (다크모드 색상 제외)
        responsive: true,
        maintainAspectRatio: false,
    };

    const getChartTextColors = () => ({ // 다크모드에 따른 텍스트 색상 반환
        titleColor: isDarkChartElement() ? '#e0e0e0' : '#333',
        legendColor: isDarkChartElement() ? '#e0e0e0' : '#333',
        tickColor: isDarkChartElement() ? '#e0e0e0' : '#666',
        gridColor: isDarkChartElement() ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
    });


    if (dom.avgPriceChartCanvas) {
        const colors = getChartTextColors();
        const avgPriceCtx = dom.avgPriceChartCanvas.getContext('2d');
        avgPriceChartInstance = new Chart(avgPriceCtx, {
            type: 'line', data: { labels: [], datasets: [] },
            options: {
                ...commonChartOptions,
                scales: {
                    y: { beginAtZero: false, ticks: { callback: function(value) { return value.toLocaleString('ko-KR') + ' 원'; }, color: colors.tickColor }, grid: { color: colors.gridColor } },
                    x: { ticks: { font: { size: 10 }, color: colors.tickColor }, grid: { color: colors.gridColor } }
                },
                plugins: {
                    title: { display: true, text: '📈 평균 매수 단가 변동 (수수료 포함)', color: colors.titleColor },
                    tooltip: { callbacks: { label: function(context) { /* ... */ } } }, // 기존 툴팁 콜백 유지
                    legend: { labels: { color: colors.legendColor } }
                }
            }
        });
    }

    if (dom.volumeChartCanvas) {
        const colors = getChartTextColors();
        const volumeCtx = dom.volumeChartCanvas.getContext('2d');
        volumeChartInstance = new Chart(volumeCtx, {
            type: 'bar', data: { labels: [], datasets: [] },
            options: {
                ...commonChartOptions,
                scales: {
                    y: { beginAtZero: true, title: {display: true, text: '수량(주)', color: colors.titleColor}, ticks: {color: colors.tickColor}, grid: {color: colors.gridColor} },
                    x: { ticks: { font: { size: 10 }, color: colors.tickColor }, grid: { color: colors.gridColor } }
                },
                plugins: {
                    title: { display: true, text: '📊 매수 회차별 수량', color: colors.titleColor },
                    legend: { display: false }, // 막대 차트는 범례 불필요
                    tooltip: { callbacks: { label: function(context) { /* ... */ } } } // 기존 툴팁 콜백 유지
                }
            }
        });
    }

    if (dom.investmentPieChartCanvas) {
        const colors = getChartTextColors();
        const pieCtx = dom.investmentPieChartCanvas.getContext('2d');
        investmentPieChartInstance = new Chart(pieCtx, {
            type: 'pie',
            data: { labels: [], datasets: [{ label: '매수 금액 비중', data: [], backgroundColor: [], borderColor: [], borderWidth: 1 }] },
            options: {
                ...commonChartOptions,
                plugins: {
                    title: { display: true, text: '💰 매수 건별 금액 비중 (%)', color: colors.titleColor },
                    tooltip: { callbacks: { label: function(context) { /* ... */ } } }, // 기존 툴팁 콜백 유지
                    legend: { position: 'top', labels: { color: colors.legendColor } }
                }
            }
        });
        dom.investmentPieChartCanvas.style.display = 'none';
    }
    // initializeCharts 끝난 후 updateDarkModeUI 호출하여 초기 색상 적용
    updateDarkModeUI(isDarkChartElement());
}

function updateCharts() {
    if (!avgPriceChartInstance && !volumeChartInstance && !investmentPieChartInstance) {
        return;
    }

    const labels = appState.purchases.map((p, i) => i === 0 ? `최초(${p.amount}주)` : `추가${i}(${p.amount}주)`);
    const avgPricesData = [];
    if (appState.purchases.length > 0) {
        let cumulativeCost = 0;
        let cumulativeAmount = 0;
        appState.purchases.forEach(p => {
            cumulativeCost += p.costWithFee;
            cumulativeAmount += p.amount;
            avgPricesData.push(cumulativeAmount > 0 ? cumulativeCost / cumulativeAmount : 0);
        });
    }
    const amountsData = appState.purchases.map(p => p.amount);

    if (avgPriceChartInstance) {
        avgPriceChartInstance.data.labels = labels;
        avgPriceChartInstance.data.datasets = [{
            label: '평균 매수 단가', data: avgPricesData,
            borderColor: 'rgba(255, 99, 132, 1)', backgroundColor: 'rgba(255, 99, 132, 0.2)',
            fill: false, tension: 0.1
        }];
        avgPriceChartInstance.options.plugins.customLines = { // afterDraw 로직은 동일하게 유지
            afterDraw: (chart) => {
                const ctx = chart.ctx; const yScale = chart.scales.y; const chartArea = chart.chartArea;
                if (!chartArea) return;
                if (appState.currentPrice > 0 && appState.purchases.length > 0) {
                    const yCurrent = yScale.getPixelForValue(appState.currentPrice);
                    if (yCurrent >= chartArea.top && yCurrent <= chartArea.bottom) {
                        ctx.save(); ctx.strokeStyle = 'green'; ctx.setLineDash([5, 5]); ctx.beginPath();
                        ctx.moveTo(chartArea.left, yCurrent); ctx.lineTo(chartArea.right, yCurrent); ctx.stroke();
                        ctx.fillStyle = isDarkChartElement() ? '#90EE90' : 'green'; ctx.textAlign = 'right';
                        ctx.fillText(`현재가: ${appState.currentPrice.toLocaleString()}원`, chartArea.right - 5, yCurrent - 5);
                        ctx.restore();
                    }
                }
                if (appState.targetROI !== 0 && dom.targetPriceResultDiv.innerText !== '' && appState.purchases.length > 0) {
                    const targetNetProfit = appState.totalInvestedCost * (appState.targetROI / 100);
                    const targetNetMarketValue = appState.totalInvestedCost + targetNetProfit;
                    let targetSellPriceVal = 0;
                    if (appState.totalAmount > 0 && (1 - appState.fees.sellRate - appState.fees.taxRate) > 0) {
                        targetSellPriceVal = targetNetMarketValue / (appState.totalAmount * (1 - appState.fees.sellRate - appState.fees.taxRate));
                    } else if (appState.totalAmount > 0) { targetSellPriceVal = Infinity; }

                    if (targetSellPriceVal > 0 && targetSellPriceVal !== Infinity) {
                        const yTarget = yScale.getPixelForValue(targetSellPriceVal);
                        if (yTarget >= chartArea.top && yTarget <= chartArea.bottom) {
                            ctx.save(); ctx.strokeStyle = 'orange'; ctx.setLineDash([5, 5]); ctx.beginPath();
                            ctx.moveTo(chartArea.left, yTarget); ctx.lineTo(chartArea.right, yTarget); ctx.stroke();
                            ctx.fillStyle = isDarkChartElement() ? '#FFD580' : 'orange'; ctx.textAlign = 'left';
                            ctx.fillText(`목표가(${appState.targetROI}%): ${targetSellPriceVal.toLocaleString()}원`, chartArea.left + 5, yTarget - 5);
                            ctx.restore();
                        }
                    }
                }
            }
        };
        avgPriceChartInstance.update('none'); // 'none'으로 애니메이션 없이 업데이트
    }

    if (volumeChartInstance) {
        volumeChartInstance.data.labels = labels;
        volumeChartInstance.data.datasets = [{
            label: '매수 수량', data: amountsData,
            backgroundColor: 'rgba(54, 162, 235, 0.6)', borderColor: 'rgba(54, 162, 235, 1)',
            borderWidth: 1
        }];
        volumeChartInstance.update('none');
    }

    if (investmentPieChartInstance) {
        if (appState.purchases.length > 0) {
            const pieLabels = appState.purchases.map((p, i) => {
                const purchaseName = i === 0 ? '최초' : `추가 ${i}`;
                return `${purchaseName} (${p.price.toLocaleString()}원, ${p.amount}주)`;
            });
            const pieData = appState.purchases.map(p => p.costWithFee);
            const baseColors = [
                'rgba(255, 99, 132, 0.7)', 'rgba(54, 162, 235, 0.7)', 'rgba(255, 206, 86, 0.7)',
                'rgba(75, 192, 192, 0.7)', 'rgba(153, 102, 255, 0.7)', 'rgba(255, 159, 64, 0.7)',
                'rgba(199, 199, 199, 0.7)', 'rgba(83, 102, 83, 0.7)', 'rgba(150, 50, 90, 0.7)', 'rgba(90, 150, 50, 0.7)'
            ];
            const backgroundColors = pieLabels.map((_, i) => baseColors[i % baseColors.length]);
            const borderColors = backgroundColors.map(color => color.replace('0.7', '1'));

            investmentPieChartInstance.data.labels = pieLabels;
            investmentPieChartInstance.data.datasets[0].data = pieData;
            investmentPieChartInstance.data.datasets[0].backgroundColor = backgroundColors;
            investmentPieChartInstance.data.datasets[0].borderColor = borderColors;
            investmentPieChartInstance.update('none');
            if (dom.investmentPieChartCanvas) dom.investmentPieChartCanvas.style.display = 'block';
        } else {
            investmentPieChartInstance.data.labels = [];
            investmentPieChartInstance.data.datasets[0].data = [];
            investmentPieChartInstance.update('none');
            if (dom.investmentPieChartCanvas) dom.investmentPieChartCanvas.style.display = 'none';
        }
    }
}

function saveData() {
  const dataToSave = {
    appState: appState,
    inputs: {
        initPrice: dom.initPriceInput.value, initAmount: dom.initAmountInput.value,
        currentPrice: dom.currentPriceInput.value, targetROI: dom.targetROIInput.value,
        buyFeeRate: dom.buyFeeRateInput.value, sellFeeRate: dom.sellFeeRateInput.value,
        taxRate: dom.taxRateInput.value,
    }
  };
  localStorage.setItem(LS_KEY_DATA, JSON.stringify(dataToSave));
  showNotification('데이터가 성공적으로 저장되었습니다.', 'success');
}

function loadData() {
  const savedData = localStorage.getItem(LS_KEY_DATA);
  if (!savedData) {
    resetAllData(false); // 이 함수 내에서 '저장된 데이터 없음' 알림 처리
    return;
  }
  const parsedData = JSON.parse(savedData);
  if (parsedData.appState) {
      if (!parsedData.appState.fees) {
          parsedData.appState.fees = { ...appState.fees }; // 현재 appState의 기본 fees 사용
      }
      // purchases 배열의 각 항목에 id가 없는 경우를 대비 (구버전 데이터 호환)
      if (parsedData.appState.purchases && parsedData.appState.purchases.length > 0) {
          parsedData.appState.purchases.forEach((p, index) => {
              if (!p.id) { // ID가 없으면 생성
                  p.id = index === 0 ? `initial-${Date.now() + index}` : `buyBlock-loaded-${Date.now() + index}`;
              }
          });
      }
      Object.assign(appState, parsedData.appState);
  } else { // appState가 없으면 현재 appState의 기본값 사용 (또는 reset)
      resetAllData(false); // loadData 초기에 resetAllData(false) 호출과 중복될 수 있으나 안전장치
      return;
  }

  if (parsedData.inputs) {
      dom.initPriceInput.value = parsedData.inputs.initPrice || '';
      dom.initAmountInput.value = parsedData.inputs.initAmount || '';
      dom.currentPriceInput.value = parsedData.inputs.currentPrice || '';
      dom.targetROIInput.value = parsedData.inputs.targetROI || '';
      dom.buyFeeRateInput.value = parsedData.inputs.buyFeeRate || (appState.fees.buyRate * 100).toString();
      dom.sellFeeRateInput.value = parsedData.inputs.sellFeeRate || (appState.fees.sellRate * 100).toString();
      dom.taxRateInput.value = parsedData.inputs.taxRate || (appState.fees.taxRate * 100).toString();
  } else { // inputs 정보가 없으면 현재 DOM 값 유지 또는 기본값으로
      dom.buyFeeRateInput.value = (appState.fees.buyRate * 100).toString();
      dom.sellFeeRateInput.value = (appState.fees.sellRate * 100).toString();
      dom.taxRateInput.value = (appState.fees.taxRate * 100).toString();
  }
  loadSettings(); // DOM 값 기준으로 appState.fees 다시 업데이트

  dom.additionalInputsContainer.innerHTML = '';
  if (appState.purchases && appState.purchases.length > 1) {
    appState.purchases.slice(1).forEach((p) => { // index 불필요, p.id 사용
      const block = document.createElement('div');
      block.className = 'buy-block';
      const blockId = p.id; // appState에 저장된 ID 사용

      block.innerHTML = `
        <div class="input-group">
            <label for="addPrice-${blockId}">추가 매수가 (원)</label>
            <input type="number" id="addPrice-${blockId}" value="${p.price}" min="0" disabled>
        </div>
        <div class="input-group">
            <label for="addAmount-${blockId}">추가 매수량 (주)</label>
            <input type="number" id="addAmount-${blockId}" value="${p.amount}" min="1" disabled>
        </div>
        <button disabled>✅ 반영됨</button>
        <button class="secondary" onclick="removeBuyBlock(this, '${blockId}')">❌ 반영된 항목 삭제</button>
      `;
      dom.additionalInputsContainer.appendChild(block);
    });
  }
  toggleInitialPurchaseInputs(appState.purchases && appState.purchases.length > 0);
  recalculateAndUpdateUI();
  showNotification('저장된 데이터를 성공적으로 불러왔습니다.', 'success');
}

function resetAllData(notify = true) {
  const defaultBuyFee = parseFloat(dom.buyFeeRateInput.defaultValue || '0.015') / 100;
  const defaultSellFee = parseFloat(dom.sellFeeRateInput.defaultValue || '0.015') / 100;
  const defaultTaxRate = parseFloat(dom.taxRateInput.defaultValue || '0.2') / 100;

  appState = {
    purchases: [], avgBuyPrice: 0, totalAmount: 0, totalInvestedCost: 0,
    fees: { buyRate: defaultBuyFee, sellRate: defaultSellFee, taxRate: defaultTaxRate },
    currentPrice: 0, targetROI: 0,
  };
  dom.initPriceInput.value = ''; dom.initAmountInput.value = '';
  toggleInitialPurchaseInputs(false);
  dom.additionalInputsContainer.innerHTML = '';

  // 수수료/세금 입력 필드를 HTML에 정의된 기본값(value 속성) 또는 지정된 기본값으로 리셋
  dom.buyFeeRateInput.value = dom.buyFeeRateInput.defaultValue || '0.015';
  dom.sellFeeRateInput.value = dom.sellFeeRateInput.defaultValue || '0.015';
  dom.taxRateInput.value = dom.taxRateInput.defaultValue || '0.2';
  loadSettings(); // DOM 변경 후 appState.fees 업데이트

  recalculateAndUpdateUI();

  if (notify) {
    localStorage.removeItem(LS_KEY_DATA);
    showNotification('모든 데이터가 초기화되었습니다.', 'success');
  } else if (!localStorage.getItem(LS_KEY_DATA) && !notify) { // loadData에서 호출되었고 저장된 데이터 없을 때
    showNotification('저장된 데이터가 없습니다. 기본값으로 시작합니다.', 'info');
  }
}

function downloadExcel() {
  if (appState.purchases.length === 0) {
    showNotification('엑셀로 저장할 데이터가 없습니다. 먼저 매수 정보를 입력해주세요.', 'error');
    return;
  }
  const today = new Date();
  const dateString = `${today.getFullYear()}${(today.getMonth() + 1).toString().padStart(2, '0')}${today.getDate().toString().padStart(2, '0')}`;
  const fileName = `물타기계산_${dateString}.xlsx`;
  const ws_data = [
    ['항목', '값', '비고'],
    ['매수 수수료율 (%)', (appState.fees.buyRate * 100).toFixed(3), ''],
    ['매도 수수료율 (%)', (appState.fees.sellRate * 100).toFixed(3), ''],
    ['세금율 (%)', (appState.fees.taxRate * 100).toFixed(3), ''],
    [],
    ['구분', '매수가(원)', '수량(주)', '매수금액(수수료포함, 원)', '누적평균단가(원)'],
  ];
  let cumulativeTotalCost = 0, cumulativeTotalAmount = 0;
  appState.purchases.forEach((p, i) => {
    // p.costWithFee는 updateAggregates에서 이미 계산되어 저장됨
    const costWithFee = p.costWithFee;
    cumulativeTotalCost += costWithFee; // 이미 계산된 costWithFee를 사용해도 되나, 엑셀용으로 명확히 누적
    cumulativeTotalAmount += p.amount;
    const cumulativeAvgPrice = cumulativeTotalAmount > 0 ? cumulativeTotalCost / cumulativeTotalAmount : 0;
    ws_data.push([
      i === 0 ? `최초 매수 (ID: ${p.id.substring(0,8)})` : `추가 매수 ${i} (ID: ${p.id.substring(0,8)})`,
      p.price, p.amount, costWithFee.toFixed(2), cumulativeAvgPrice.toFixed(2)
    ]);
  });
  ws_data.push([]);
  ws_data.push(['총계']);
  ws_data.push(['총 보유 수량 (주)', appState.totalAmount]);
  ws_data.push(['총 투자 원금 (수수료 포함, 원)', appState.totalInvestedCost.toFixed(2)]);
  ws_data.push(['평균 매수 단가 (수수료 포함, 원)', appState.avgBuyPrice.toFixed(2)]);

  if (dom.profitResultTableDiv.innerHTML !== '' && appState.currentPrice > 0) { // 손익계산 결과가 실제로 있을 때
    ws_data.push([]);
    ws_data.push(['손익 계산 정보 (현재가: ' + appState.currentPrice.toLocaleString() + '원)']);
    const grossMarketValue = appState.currentPrice * appState.totalAmount;
    const netMarketValue = grossMarketValue * (1 - appState.fees.sellRate - appState.fees.taxRate);
    const profitOrLoss = netMarketValue - appState.totalInvestedCost;
    const roi = appState.totalInvestedCost > 0 ? (profitOrLoss / appState.totalInvestedCost) * 100 : 0;
    let breakEvenPrice = 0;
    if (appState.totalAmount > 0 && (1 - appState.fees.sellRate - appState.fees.taxRate) > 0) {
        breakEvenPrice = appState.totalInvestedCost / (appState.totalAmount * (1 - appState.fees.sellRate - appState.fees.taxRate));
    } else if (appState.totalAmount > 0) breakEvenPrice = Infinity;
    ws_data.push(['현재 평가 금액 (차감 전)', grossMarketValue.toFixed(2)]);
    ws_data.push(['예상 순 평가 금액 (차감 후)', netMarketValue.toFixed(2)]);
    ws_data.push(['예상 순손익', profitOrLoss.toFixed(2)]);
    ws_data.push(['예상 수익률 (%)', roi.toFixed(2)]);
    ws_data.push(['손익분기점 주가', breakEvenPrice === Infinity ? "도달 불가능" : breakEvenPrice.toFixed(2)]);
  }
  if (dom.targetPriceResultDiv.innerText !== '' && appState.targetROI !== 0) { // 목표가 결과가 실제로 있을 때
    const targetROI = appState.targetROI;
    const targetNetProfit = appState.totalInvestedCost * (targetROI / 100);
    const targetNetMarketValue = appState.totalInvestedCost + targetNetProfit;
    let targetSellPrice = 0;
    if (appState.totalAmount > 0 && (1 - appState.fees.sellRate - appState.fees.taxRate) > 0) {
        targetSellPrice = targetNetMarketValue / (appState.totalAmount * (1 - appState.fees.sellRate - appState.fees.taxRate));
    } else if (appState.totalAmount > 0) targetSellPrice = Infinity;
    ws_data.push([]);
    ws_data.push(['목표 수익률 기반 매도 가격 (목표: ' + targetROI + '%)']);
    ws_data.push(['목표 매도가', targetSellPrice === Infinity ? "도달 불가능" : targetSellPrice.toFixed(2)]);
    ws_data.push(['예상 순수익 금액', targetNetProfit.toFixed(2)]);
  }
  const wb = XLSX.utils.book_new();
  const ws = XLSX.utils.aoa_to_sheet(ws_data);

  if (ws_data.length > 5 && ws_data[5] && ws_data[5].length > 0) {
    const colSpecs = ws_data[5].map((_, i) => {
        let maxLen = 0;
        ws_data.forEach(row => {
            if (row[i] && String(row[i]).length > maxLen) maxLen = String(row[i]).length;
        });
        return { wch: Math.max(10, maxLen + 2) };
    });
    ws['!cols'] = colSpecs;
  }

  XLSX.utils.book_append_sheet(wb, ws, '투자계산내역');
  XLSX.writeFile(wb, fileName);
  showNotification('엑셀 파일이 성공적으로 다운로드되었습니다.', 'success');
}

function toggleDarkMode() {
  const isDark = document.body.classList.toggle('dark');
  localStorage.setItem(LS_KEY_DARK_MODE, isDark ? 'on' : 'off');
  updateDarkModeUI(isDark);
}

function updateDarkModeUI(isDark) {
    dom.darkModeBtn.innerText = isDark ? '☀️ 라이트모드 ON' : '🌙 다크모드 ON';

    const colors = { // 다크모드에 따른 색상 객체화
        titleColor: isDark ? '#e0e0e0' : '#333',
        legendColor: isDark ? '#e0e0e0' : '#333',
        tickColor: isDark ? '#e0e0e0' : '#666',
        gridColor: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
    };

    [avgPriceChartInstance, volumeChartInstance, investmentPieChartInstance].forEach(chart => {
        if (chart) {
            if (chart.options.scales) {
                if (chart.options.scales.x) {
                    chart.options.scales.x.ticks.color = colors.tickColor;
                    chart.options.scales.x.grid.color = colors.gridColor;
                    if (chart.options.scales.x.title) chart.options.scales.x.title.color = colors.titleColor;
                }
                if (chart.options.scales.y) {
                    chart.options.scales.y.ticks.color = colors.tickColor;
                    chart.options.scales.y.grid.color = colors.gridColor;
                    if (chart.options.scales.y.title) chart.options.scales.y.title.color = colors.titleColor;
                }
            }
            if (chart.options.plugins.title) chart.options.plugins.title.color = colors.titleColor;
            if (chart.options.plugins.legend) chart.options.plugins.legend.labels.color = colors.legendColor;
            chart.update();
        }
    });
}
</script>
</body>
</html>